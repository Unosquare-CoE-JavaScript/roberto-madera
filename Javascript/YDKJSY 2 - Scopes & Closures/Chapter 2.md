## Illustrating Lexical Scope

It is fundamental to understand properly how the scope works in JS and never rely on guesses or intuition. One useful way understand how the scope works properly is by using metaphors as a way to illustrate how the scope works.

### Understanding the scope
One useful metaphor for the scope is by visualizing variables and identifiers as colored marbles and scopes (either function or block scopes) a colored bucket containers. Each marble would be sorted into it's proper colored container (e.g. green marbles into a green bucket), these buckets can be nested into each other. Each marble color is determined by it's container, so each marble created inside a container will have the same color. We can apply this metaphor and visualize that each variable or identifier declared is based on the scope where it was declared in. The scopes are determined during compilation based on where the functions and blocks are declared and on it's nesting.

Another way we could visualize the scope is as a conversation between 'friends'. We can think of 3 different parts that are responsible for processing our program: *Engine* (Responsible for all the program compilation and execution), *Compiler* (Handles the parsing and code generation) and *Scope manager* (Maintains a list of all declared variables and sets and enforces rules for how these are available during exectuion). The process for which these 3 parts handle code could be seen as various conversations, the first of which occurs between *Compiler* and *Scope Manager*, Compiler parses the code and for each variable or declaration it will ask the scope manager if it has that declaration on a scope list, and if not, the scope manager will create it. This conversation will go on back and forth between the two until all the program it's parsed. Once execution begins the conversation shifts to the *Engine* and *Scope Manager*, where the engine asks the scope manager for each identifier, for which it will provide the proper reference to the engine. Depending on the identifier the engine might associate a function to the identifier or associate a *target* to it.

As explained before on the previous chapter, during compilation on each reference it's determined if it's *lexically available* and if not, a new scope will be created. Continuing with the previous metaphor we can visualize this during the engine and scope manager conversation. Each different scope has it's own scope manager, and everytime the engine needs to consult a scope manager about any identifier reference, if it can't find a reference to it, it will ask the next outer scope manager and will continue until a scope manager finds a reference. 

One important thing to note about this process, is how errors are handled when the Engine couldn't encounter a reference on any of the scope managers. When a reference reaches the outer global scope, depending whenever strict mode is enabled or not, the global scope will either create the reference for the Engine in non strict mode, or will throw a *ReferenceError* for strict mode. As stated before, it's never recommended to not use strict mode.